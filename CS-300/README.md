   - What was the problem you were solving in the projects for this course?

	The problem was how to decide on the best data structure for a given task.  The projects in this course examined the time complexity of searching, sorting, adding and removing data from several common data structures.

   - How did you approach the problem? Consider why data structures are important to understand.

        I relied heavily on the pseudocode from the reading and exercises.  Data structures have tradeoffs in time and space complexity.  Generally, the faster a data structure performs a task, the more overhead it has in terms of memory storage.  Knowing when to focus on speed or space is a critical part of designing software, especially for embedded systems where space can still be an issue.

   - How did you overcome any roadblocks you encountered while going through the activities or project?

    The biggest challenge I had was parsing input.  This is not as trivial in c++ as in other programming languages like python. Online research was key to developing strategies to overcome this.

   - How has your work on this project expanded your approach to designing software and developing programs?
   
        Using Big O notation during the design and pseudo code phase can help inform choices based on how the program and its features will be used.  An algorithm with a higher time complexity may be preferred if the functionality is used infrequently, especially if it has a smaller space complexity.  Space and time are always tradeoffs in computer programming.  

    - How has your work on this project evolved the way you write programs that are maintainable, readable, and adaptable?

        This project has helped me develop a better understanding of class structures and how to group like functionality for portability and security with private features and methods.  
